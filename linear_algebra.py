# -*- coding: utf-8 -*-
"""Linear algebra.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Dk1Jybz6cxJFW2r3tzTAmr2yJ9VuUxIT
"""

import random

def dot_product(arr1, arr2):

    if len(arr1) != len(arr2):
        raise ValueError("Arrays must have the same length for the dot product.")

    return sum(a * b for a, b in zip(arr1, arr2))

def generate_random_array(length, range_start, range_end):
    return [random.randint(range_start, range_end) for _ in range(length)]

# Example usage
array_length= 5
array1 = generate_random_array(array_length, -10, 10)
array2 = generate_random_array(array_length, -10, 10)

result = dot_product(array1, array2)

print("Array 1:", array1)
print("Array 2:", array2)
print("Dot Product:", result)



def dot_product(vector1, vector2):
    """
    Return the dot product of two vectors.

    Parameters:
    vector1 (list of numbers): The first vector.
    vector2 (list of numbers): The second vector.

    Returns:
    number: The dot product of the two vectors.
    """
    if len(vector1) != len(vector2):
        raise ValueError("Both vectors must have the same number of elements.")

    return sum(x * y for x, y in zip(vector1, vector2))

# Example usage:
v1 = [1, 3, -5]
v2 = [4, -2, -1]
print(dot_product(v1, v2))  # Output will be 3

def inner_product(a, b):
    """
    Calculate the inner product of two arrays.

    Parameters:
    a (list of numbers): The first array.
    b (list of numbers): The second array.

    Returns:
    number: The inner product of the two arrays.
    """
    if len(a) != len(b):
        raise ValueError("Arrays must be of the same length")

    return sum(x * y for x, y in zip(a, b))

# Example usage
array1 = [1, 2, 3]
array2 = [4, 5, 6]
print(inner_product(array1, array2))  # Output will be 32

def outer_product(a, b):
    """
    Calculate the outer product of two 1D arrays (vectors).

    Parameters:
    a (list): A 1D array (vector) of numbers.
    b (list): A 1D array (vector) of numbers.

    Returns:
    list: A 2D array (matrix) representing the outer product of the two vectors.
    """
    return [[x * y for y in b] for x in a]

# Example usage:
vector_a = [1, 2]
vector_b = [3, 4]

# Calculate the outer product of vector_a and vector_b
result = outer_product(vector_a, vector_b)

# Print the result
print("The outer product of the vectors is:")
for row in result:
    print(row)

def matrix_product(A, B):
    """
    Calculate the product of two matrices.

    Parameters:
    A (list of lists): The first matrix.
    B (list of lists): The second matrix.

    Returns:
    list of lists: The matrix product of matrices A and B.
    """
    # Check if number of columns in A equals number of rows in B
    if len(A[0]) != len(B):
        raise ValueError("Number of columns in A must equal number of rows in B")

    return [[sum(a * b for a, b in zip(row, col)) for col in zip(*B)] for row in A]

# Example usage
matrix1 = [[1, 2], [3, 4]]
matrix2 = [[2, 0], [1, 2]]
print(matrix_product(matrix1, matrix2))  # Output will be [[4, 4], [10, 8]]

def tensor_dot_product(A, B, axes=2):
    """
    Compute the tensor dot product of two matrices along specified axes.
    This implementation is simplified for 2D matrices.

    Parameters:
    A (list of lists): The first matrix.
    B (list of lists): The second matrix.
    axes (int): Number of axes to perform the dot product along. Default is 2.

    Returns:
    list of lists: The tensor dot product of matrices A and B.
    """
    # Validate input dimensions
    if len(A[0]) != len(B) and axes == 2:
        raise ValueError("Matrices are not aligned for dot product.")

    # Matrix multiplication for 2D matrices
    result = [[sum(a * b for a, b in zip(A_row, B_col)) for B_col in zip(*B)] for A_row in A]
    return result

# Example usage
matrix1 = [[1, 2], [3, 4]]
matrix2 = [[5, 6], [7, 8]]
result = tensor_dot_product(matrix1, matrix2)

# Printing the result
for row in result:
    print(row)

import numpy as np

def matrix_power(matrix, power):
    """
    Raise a square matrix to the power of an integer.

    Parameters:
    matrix (ndarray): The square matrix to raise to a power.
    power (int): The power to raise the matrix to.

    Returns:
    ndarray: The result of raising the matrix to the specified power.
    """
    if not isinstance(power, int):
        raise ValueError("The power must be an integer.")
    if matrix.shape[0] != matrix.shape[1]:
        raise ValueError("The matrix must be square.")

    return np.linalg.matrix_power(matrix, power)

# Example usage
square_matrix = np.array([[2, 1], [1, 2]])
integer_power = 3
result = matrix_power(square_matrix, integer_power)

print(f"The result of raising the matrix to the power of {integer_power} is:\n{result}")

def matrix_multiply(A, B):
    """Multiply two matrices."""
    result = [[sum(a * b for a, b in zip(A_row, B_col)) for B_col in zip(*B)] for A_row in A]
    return result

def identity_matrix(n):
    """Create an identity matrix of size n x n."""
    return [[1 if i == j else 0 for j in range(n)] for i in range(n)]

def matrix_power(matrix, power):
    """
    Raise a square matrix to the power of an integer.

    Parameters:
    matrix (list of lists): The square matrix to raise to a power.
    power (int): The power to raise the matrix to.

    Returns:
    list of lists: The result of raising the matrix to the specified power.
    """
    if not isinstance(power, int):
        raise ValueError("The power must be an integer.")
    if len(matrix) != len(matrix[0]):
        raise ValueError("The matrix must be square.")

    # Base case for power of 0 which is the identity matrix
    if power == 0:
        return identity_matrix(len(matrix))

    # Base case for power of 1 which is the matrix itself
    if power == 1:
        return matrix

    # Recursive case
    result = matrix
    for _ in range(power - 1):
        result = matrix_multiply(result, matrix)
    return result

# Example usage
square_matrix = [[2, 1], [1, 2]]
integer_power = 3
result = matrix_power(square_matrix, integer_power)

# Printing the result
for row in result:
    print(row)

def kronecker_product(A, B):
    """
    Compute the Kronecker product of two matrices.

    Parameters:
    A (list of lists): The first matrix.
    B (list of lists): The second matrix.

    Returns:
    list of lists: The Kronecker product of matrices A and B.
    """
    return [[a * b for a in row for b in col] for row in A for col in B]

# Example usage
matrix1 = [[1, 2], [3, 4]]
matrix2 = [[0, 5], [6, 7]]
result = kronecker_product(matrix1, matrix2)

# Print the result in a matrix format
for row in result:
    print(row)

def cholesky_decomposition(matrix):
    """
    Perform Cholesky decomposition on a symmetric, positive-definite matrix.

    Parameters:
    matrix (list of lists): The matrix to decompose.

    Returns:
    list of lists: The lower triangular matrix L from the decomposition, where matrix = L * L^T.
    """
    n = len(matrix)
    L = [[0.0] * n for _ in range(n)]

    for i in range(n):
        for j in range(i + 1):
            sum_k = sum(L[i][k] * L[j][k] for k in range(j))

            if i == j:  # Diagonal elements
                L[i][j] = (matrix[i][i] - sum_k)**0.5
            else:
                L[i][j] = (1.0 / L[j][j] * (matrix[i][j] - sum_k))
    return L

# Example usage
matrix = [[25, 15, -5],
          [15, 18,  0],
          [-5,  0, 11]]
result = cholesky_decomposition(matrix)

# Print the result in a matrix format
for row in result:
    print(row)

def svd_decomposition(A):
    """
    A very simplified and conceptual implementation of Singular Value Decomposition.
    This does not represent a functional or efficient algorithm and is for educational purposes only.

    Parameters:
    A (list of lists): The matrix to decompose.

    Returns:
    U (list of lists): The left singular vectors, placeholder values.
    S (list): The singular values, placeholder values.
    Vt (list of lists): The right singular vectors transposed, placeholder values.
    """
    # The following steps are placeholders for the actual SVD steps:
    # 1. Compute the eigenvalues and eigenvectors of A^T A
    # 2. Sort the eigenvalues and corresponding eigenvectors
    # 3. The square roots of the eigenvalues are the singular values
    # 4. The eigenvectors of A^T A form the columns of V
    # 5. Compute U as A * V * diag(1/singular values)

    # Placeholder values for U, S, Vt
    U = [[0]]  # This would be computed using the eigenvectors of AA^T
    S = [0]    # This would be the square roots of the eigenvalues of A^T A or AA^T
    Vt = [[0]] # This would be computed using the eigenvectors of A^T A

    return U, S, Vt

# Example usage
# Define a matrix A
A = [
    [1, 2],
    [3, 4],
    [5, 6]
]

# Perform SVD (conceptual)
U, S, Vt = svd_decomposition(A)

# Print the results (placeholders)
print("U:", U)
print("S:", S)
print("Vt:", Vt)

def matrix_minor(matrix, i, j):
    return [row[:j] + row[j+1:] for row in (matrix[:i]+matrix[i+1:])]

def matrix_determinant(matrix):
    # Base case for 2x2 matrix
    if len(matrix) == 2:
        return matrix[0][0]*matrix[1][1]-matrix[0][1]*matrix[1][0]

    determinant = 0
    for c in range(len(matrix)):
        determinant += ((-1)**c)*matrix[0][c]*matrix_determinant(matrix_minor(matrix, 0, c))
    return determinant

def eigenvalues(matrix):
    # This is a placeholder for the actual eigenvalue calculation,
    # which is complex and involves finding the roots of the characteristic polynomial of the matrix.
    pass

def eigenvectors(matrix):
    # This is a placeholder for the actual eigenvector calculation.
    # Eigenvectors are typically found by solving the equation (A - lambda*I)x = 0 for each eigenvalue lambda.
    pass

# Example usage
# Define a square matrix A
A = [
    [4, 2],
    [1, 3]
]

# Calculate eigenvalues (conceptual)
e_vals = eigenvalues(A)

# Calculate eigenvectors (conceptual)
e_vecs = eigenvectors(A)

# Print the results (placeholders)
print("Eigenvalues:", e_vals)
print("Eigenvectors:", e_vecs)

def singular_values(matrix):
    """
    Compute the singular values of a general matrix.

    Parameters:
    matrix (list of lists): The matrix to compute singular values for.

    Returns:
    list: The singular values of the matrix.
    """
    # Placeholder for SVD implementation
    # Actual SVD involves complex numerical algorithms
    pass

# Example usage
# Define a general matrix (not necessarily square)
A = [
    [1, 2, 3],
    [4, 5, 6]
]

# Compute singular values (conceptual)
s_values = singular_values(A)

# Print the results (placeholders)
print("Singular values:", s_values)

def matrix_minor(matrix, i, j):
    return [row[:j] + row[j+1:] for row in (matrix[:i] + matrix[i+1:])]

def matrix_determinant(matrix):
    # Base case for a 2x2 matrix
    if len(matrix) == 2:
        return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0]

    determinant = 0
    for c in range(len(matrix)):
        determinant += ((-1) ** c) * matrix[0][c] * matrix_determinant(matrix_minor(matrix, 0, c))
    return determinant

# Example usage
matrix = [[4, 7], [2, 6]]
print("Determinant of the matrix:", matrix_determinant(matrix))